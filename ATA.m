function [GPE,offset] = ATA(f0,truth,p,offset,offsetOK,plt)
% -------------------------- Input ------------------------------ 
% f0: estimated sequence generated by the method to be evaluated
% truePitch: truth sequence
% p: threshold for GPE calculation 0.2 0.1 0.05
% offset: offset input if offsetOK is 1
% offsetOK: offset found flag 1 0, 1 means use input offset, 0 means ignore input and search offset automatically 
% plt: wether plot the alignment 1 0
% -------------------------- Output -----------------------------
% offset: shift number of frame size for optimal alignment
% GPE(%): corresponding gpe with the offset

% --------------------------- NOTE ------------------------------
% (1) this code only need to run one time under high SNR conditions for a certain
% pitch estimation method, a certain dataset, and a certain ground truth method
% once the offset is obtained, the offset can be used
% as the input setup of "calculateMetric.m" directly.

% Example
% 0 | 0 | 0 | 0 | 0 | 200 | 201 | .....>> truth      sequence <<...... | 196 | 195 | 190 | 0 | 0 | 0 | 0 | 0 |
%   >>    range  << |     |     | .....>> estimate   sequence <<...... |     | >>   range    <<  
% -5| -4| -3| -2| -1|  0  |  1  |  2  |  3  |  4  | <<<<<<<<<<<.... front are offset values 

if nargin < 6
    plt = 0;      % default no display
end
if nargin < 5
    offsetOK = 0; % default offset has not been found
end
if nargin < 4
    offset   = 0; % default offset is 0
end
if nargin < 3
    p = 0.2;
end 

% ------------------------ start of pre processing
edge = [50 400];
nanIdx = isnan(f0);     % find nan and correct as 0 
f0(nanIdx) = 0;
overIdx = f0 > edge(2); % find pitches outside edge and correct as upper and 0, for MAE or display use, or the MAE maybe too large for a too high error estimate
f0(overIdx) = edge(2);
overIdx = f0 < edge(1); 
f0(overIdx) = 0;
% ------------------------ end of pre processing

if ~offsetOK                        % offset has not been found, find offset first

    % Step 1: Determine the searching range for temporal alignment
    H = 10; % general hop size is 10ms, and the frame length is general less than 100ms, thus maximum temporal offset is 10 frames
    GPE_table = zeros(2*H+1,1);     % number of searching

    % Step 2: Alignment and similarity calculation
    idx = 1;
    for shift = -H:H                % shift idx
        f0_adj          = f0(:,1);
        truth_adj       = truth;
        voiced_adj      = truth~=0;
        if shift < 0               
            truth_adj   = [zeros(1,abs(shift)),truth_adj']';   % padding '0's at truth sequence head
            voiced_adj  = [~true(1,abs(shift)),voiced_adj']';
        elseif shift > 0
            f0_adj      = [zeros(1,abs(shift)),f0_adj']';      % padding '0's at estimate sequence head
        end
        
        shorterLength = min( length(f0_adj), length(truth_adj) ); % cut tail to ensure the same length
        f0_adj = f0_adj(1:shorterLength,1);
        truth_adj = truth_adj(1:shorterLength,1);
        voiced_adj  = voiced_adj(1:shorterLength,1);
        
        kk = abs(f0_adj(voiced_adj) - truth_adj(voiced_adj)) > truth_adj(voiced_adj).*p;
        if isempty(kk)  % special condition of None error ( kong == empty )
            kk = 0;     % none error means GPE is 0
        end
        GPE = mean(kk).*100;
        GPE_table(idx,1) = GPE;
        idx = idx + 1;
    end
    [minGPE,loc] = min (GPE_table); % find the offset corresponding to the smallest GPE
    offset = loc - H - 1;           % correct the offset
end

% Step 3: Adjust pitch sequence using offset
f0_adj      = f0;
truth_adj   = truth;
voiced_adj  = truth~=0;

% handle head
if offset < 0                          
    truth_adj    = [zeros(1,abs(offset)),truth_adj']';      % padding '0's at truth sequence head
    voiced_adj   = [~true(1,abs(offset)),voiced_adj']';
elseif offset > 0
    f0_adj       = [zeros(1,abs(offset)),f0_adj']';         % padding '0's at estimate sequence head
end

% handle tail
shorterLength = min( length(f0_adj), length(truth_adj) );   % cut tail to ensure the same length
f0_adj = f0_adj(1:shorterLength,1);
truth_adj = truth_adj(1:shorterLength,1);
voiced_adj  = voiced_adj(1:shorterLength,1);

% --------------------- Index calculation ---------------------------------
voiced_final = voiced_adj;              % version 2
f0_final     = f0_adj;
truth_final  = truth_adj;

f0_voiced            = f0_final(voiced_final);
true_voiced          = truth_final(voiced_final);
DeltaF       = abs(f0_voiced - true_voiced)./true_voiced;
GPE_pre      = DeltaF > p;
SumRn        = sum( voiced_final );
if isempty (GPE_pre)    % special condition of None error ( kong == empty )
    GPE = 0;            % none error means GPE is 0
else
    GPE = sum( GPE_pre )/SumRn*100;   
end
FPE_pre      = DeltaF( DeltaF < p);
if isempty (FPE_pre)    % special condition of None error ( kong == empty )
    FPE = 0;            % none error means GPE is 0
else
    FPE = mean( FPE_pre )*100;   
end

if  isnan(GPE) || isnan(FPE) 
    pause % exception handling
end

% --------------------- plot to check the best offset ---------------------
if plt == 1 && ~offsetOK
    fontSize  = 12;
    fontName  = 'Times';
    linewidth = 1.5;
    disType   = 1;
% ---------------------------- below is the first type of display --------- 
    if disType == 1
        f0_adj(~voiced_final)  = 0; % set unvoiced as 0
    
        figure
        subplot(3,1,1);
        plot(truth_adj,'-r','LineWidth',linewidth);
        hold on
        plot(f0_adj,'-b','LineWidth',linewidth);
        hold off
        legend({'Pitch estimates','Ground truths'},'NumColumns',2,'fontsize',fontSize,'fontname',fontName);
        text(20,1.2*max(truth_adj),strcat('GPE = ',string(round(GPE_table(min(max(1,offset + 1 + H - 1),H)),1)),'  Offset = ',string(offset-1)),'Color','m','fontsize',fontSize,'fontname',fontName);
        xlabel('Frame Number','fontsize',fontSize,'fontname',fontName);
    
        subplot(3,1,2);
        plot(truth_adj,'-r','LineWidth',linewidth);
        hold on
        plot(f0_adj,'-b','LineWidth',linewidth);
        hold off
        legend({'Pitch estimates','Ground truths'},'NumColumns',2,'fontsize',fontSize,'fontname',fontName);
        text(20,1.2*max(truth_adj),strcat('GPE = ',string(round(GPE_table(min(max(1,offset + 1 + H),H)),1)),'  Offset = ',string(offset)),'Color','m','fontsize',fontSize,'fontname',fontName);
        xlabel('Frame Number','fontsize',fontSize,'fontname',fontName);
    
        subplot(3,1,3);
        plot(truth_adj,'-r','LineWidth',linewidth);
        hold on
        plot(f0_adj,'-b','LineWidth',linewidth);
        hold off
        legend({'Pitch estimates','Ground truths'},'NumColumns',2,'fontsize',fontSize,'fontname',fontName);
        text(20,1.2*max(truth_adj),strcat('GPE = ',string(round(GPE_table(min(max(1,offset + 1 + H + 1),H)),1)),'  Offset = ',string(offset+1)),'Color','m','fontsize',fontSize,'fontname',fontName);
        xlabel('Frame Number','fontsize',fontSize,'fontname',fontName);
        ylabel('Pitch (Hz)','fontsize',fontSize,'fontname',fontName);
% --------------------------- Boundary line of the two types of display ---
    else
        scrsz = get(0,'ScreenSize');
        figure1 = figure('Position',[10 100 1000 300]);
        
        axis xy;
        ylim([50,400]); 
        ylabel('Pitch (Hz)','fontsize',fontSize,'fontname',fontName);
        xlabel('Time (s)','fontsize',fontSize,'fontname',fontName);
        set(gca, 'XTick', [1:1:30], 'YTick', [50:100:400],'fontsize',fontSize,'fontname',fontName)
        hold on;
    
        showStart = 1;
        showEnd = 3000;
    
        HorTime = 0.01:0.01:length(truth_adj)/100;
        truePitchIdx = truth_adj > 0;
        i_max        = size(truePitchIdx,1);
        i = showStart;
        while i <= showEnd %size(truePitchIdx,1) % show by segment
            if truePitchIdx(i) == 1 
                Seg_Start = i;                                        
                Seg_End = i+1;                                         
                while truePitchIdx(Seg_End) == 1 && Seg_End <= i_max   % roll to right to find the segment end
                    Seg_End = Seg_End + 1; 
                    if Seg_End > size(truth_adj)
                        break;
                    end
                end
                Seg_End   = Seg_End - 1;                    % correct the end index
                
                plot(HorTime(1,Seg_Start:Seg_End)', truth_adj(Seg_Start:Seg_End,1), 'm-','LineWidth',linewidth);
                plot(HorTime(1,Seg_Start:Seg_End)', f0_adj(Seg_Start:Seg_End,1), 'k-','LineWidth',linewidth);
                i = Seg_End + 1;
            else
                i = i + 1; 
            end
        end
    end
% ---------------------------- above is the second type of display --------
end
